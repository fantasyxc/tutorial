# 《浏览器工作原理与实践》
[TOC]

课程地址：
https://time.geekbang.org/column/article/116572

1. Node.js是基于Chrome的js引擎V8来实现的，特点是可以脱离浏览器环境来执行js。

## 1. 浏览器介绍
### 1.1. Chrome架构
#### 1.1.1. 进程和线程
- 一个进程就是一个程序的运行实例：启动一个程序时，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程；进程结束后会回收所占用内存；进程之间的内容相互隔离，进程之间通过IPC机制通讯
- 线程是依附进程的，不能单独存在，由进程来启动和管理；线程之间共享进程中的数据

#### 1.1.2. 单进程浏览器
1. 单进程浏览器是指浏览器的所有功能模块都运行在同一个进程里，这些模块包含了网络、插件、JS运行环境、渲染引擎和页面等。
2. 单进程浏览器的问题：
（1）不稳定：插件、渲染引擎模块的崩溃会导致整个浏览器崩溃
（2）不流畅：所有页面的渲染模块、JS执行环境以及插件都运行在同一线程中；页面内存泄露会导致浏览器变慢
（3）不安全：插件可以使用C/C++等代码编写，可以获取到操作系统的任意资源；页面脚本可以通过浏览器漏洞获取系统权限

#### 1.1.3. 多进程浏览器
- Chrome浏览器打开1个页面，启动了4个进程
- Chrome浏览器把插件进程和渲染进程所在沙箱里面，使得恶意程序无法突破沙箱去获取系统权限
- 最新的Chrome进程架构
	- 浏览器主进程（Browser Process）：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能
	- 渲染进程（Render Process）（多个，sandbox）：将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排班引擎Blink和JavaScript引擎V8都是运行在该进程中；默认情况下，Chrome会为每个Tab标签创建一个渲染进程
	- GPU进程（GPU Process）：UI界面都采用GPU绘制 
	- 网络进程（Network Process）：网络资源的加载
	- 插件进程（Plugin Process）（多个， 部分sandbox）：插件的运行

### 1.2. TCP/IP协议
- 首次加载速度FP（First Paint）：从页面加载到首次开始绘制的时长

1. IP（把数据包送达目的主机）：网际协议，Internet Protocol，IP数据包
2. UDP（主机将数据包转交给应用）：用户数据包协议，User Datagram Protocol，包含端口信息，不能保证数据可靠性，传输速度快
3. TCP（数据被完整的送达应用程序）：传输控制协议，Transmission Control Protocol，一种面向连接的、可靠的、基于字节流的传输层通信协议
	- 建立连接：三次握手
	- 传输数据：接收端需要对每个数据包进行确认操作
	- 断开连接：四次挥手

### 1.3. HTTP协议
- 参考地址：https://developer.mozilla.org/zh-CN/docs/Web/HTTP

- HTTP：建立在TCP连接的基础上，是一种允许浏览器向服务器获取资源的协议
	1. 构建请求
	2. 查找缓存
	3. 准备IP地址和端口（DNS）
	4. 等待TCP队列（Chrome的TCP队列是6）
	5. 建立TCP连接
	6. 发送HTTP请求（GET、POST）
	7. 服务器处理请求
	8. 服务器返回请求
	9. 断开TCP连接

- curl查看返回请求数据
```shell
curl -i https://time.geekbang.org/ # 返回响应行、响应头和响应体的数据
curl -I geekbang.org # 只需要获取响应头和响应行数据
```

- 重定向：包含在响应头 `Location` 字段的内容，浏览器获取该字段地址，并重新导航

- Cache（缓存）：响应头中包含 `Cache-Control:Max-age=2000` 字段

- Cookie：响应头中包含 `Set-Cookie` 字段

### 1.4. 导航流程
### 1.4.1. 用户从浏览器输入请求信息
1. 判断为搜索内容，使用浏览器默认搜索引擎，合成带搜索关键字的URL
2. 判断内容符合URL规则，把内容加上协议合成完整的URL
3. 通过进程间通信（IPC）发送到网络进程

### 1.4.2. 网络进程发起URL请求
1. 网络进程先先找本地缓存是否有缓存资源，如果有则直接返回给浏览器进程，如果没有需要进入网络请求流程，先使用DNS解析获取域名的IP地址，如果为HTTPS协议还需要建立TLS连接
2. 建立TCP连接，构建请求信息并发送
3. 服务器接收请求信息后，会生成响应数据并发给网络进程，网络进程开始解析响应头内容
	1. 返回码301/302：需要重定向
	2. 返回码200：一切正常，浏览器可以继续处理请求
	3. `Content-Type` ：浏览器服务器返回的响应体数据是什么类型，不同类型处理流程不同

### 1.4.3. 浏览器进程开始准备渲染进程
- 同一站点：根域名+协议，包括该根域名下所有子域名和不同端口
- Chrome的默认策略 `process-per-site-instance` 是每个标签打开一个渲染进程，如果新页面与当前页面属于同一站点则会复用父页面的渲染进程

### 1.4.4. 提交文档（替换页面内容）
- “提交文档”的消息是由浏览器进程发出的，渲染进程接收到消息后，会与网络进程建立传输数据的“管道”
- 等文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程
- 浏览器进程在收到消息后，会更新浏览器界面状态，包括：安全状态、地址栏URL、前进后退的历史状态，并更新Web页面

### 1.4.5. 渲染阶段
- 解析和子资源加载
- 页面生成完成后，渲染进程发送一个消息给浏览器进程，浏览器进程收到消息后，停止标签图标上的加载动画

### 1.5 渲染流程
- 渲染数据
	- HTML：超文本标记语言，包括文本、标签
	- CSS：层叠样式表，包括选择器、属性、值
	- JS：JavaScript，通过JS页面修改内容

#### 1.5.1. 构建DOM树：解析HTML文件成树状结构的DOM

#### 1.5.2. 样式计算
1. 渲染引擎将CSS文件转换为styleSheets结构，CSS文件来源包括：
	- 通过link引用的外部CSS文件
	- `<style>`标记内的CSS
	- 元素的style属性内嵌的CSS
2. 转换样式表中的属性值，使其标准化（数值）
3. 计算出DOM树中每个节点的具体样式，保存在 `ComputedStyle` 的结构内
	- 继承规则：每个DOM节点都包含父节点的样式
	- 层叠规则：如何合并来自多个源的属性值的算法

#### 1.5.3. 布局阶段：计算出DOM树中可见元素的几何位置（XY）
1. 创建布局树：只包含可见元素，忽略掉不可见的节点，如使用 `display:none` 属性的元素
2. 布局计算：计算布局树节点的坐标位置，重新写回布局树中

#### 1.5.4. 分层
- 为特定的节点生成专用的图层，并生成一棵对应的图层树LayerTree（z轴）
- 如果一个节点没有对应的层，那这个节点就属于父节点的图层
- 参考地址：https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context
1. 拥有层叠上下文属性的元素会被提升为单独的一层，包括明确定位属性的元素、定义透明属性的元素、使用CSS滤镜的元素等
2. 需要剪裁（clip）的地方也会被创建为图层，如文本框中内容超过文本框大小，使用了滚动条的时候

#### 1.5.5. 绘制
- 渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后把这些指令按照顺序组成一个待绘制列表

#### 1.5.6. 栅格化（raster）操作
- 视口（ViewPort）：屏幕上页面的可见区域，页面的其中用户看到的一部分
- 栅格化：将图块转换为位图，图块是栅格化执行的最小单位
- 通常栅格化过程都会使用GPU来加速生成，生成的位图被保存在GPU内存中
1. 当图层的绘制列表准备好之后，主线程会把该绘制列表提交（Commit）结合成线程
2. 合成线程会将图层划分为图块（tile），图块大小通常是 256*256 或者 512*512
3. 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的；渲染进程维护一个栅格化的线程池，所有的图块栅格化都是在线程池内执行

#### 1.5.7. 合成和显示
1. 所有图块都被光栅化后，合成线程就会生成一个绘制图块的命令 `DrawQuad` ，将该命令提交给浏览器进程
2. 浏览器线程中的 `viz` 组件，用来接收合成线程发过来的 `DrawQuad` 命令，然后根据该命令将页面内容绘制到内存中，最后将内存显示在屏幕上

1. 重排：更新了元素的几何属性后，浏览器会触发重新布局，更新完整的渲染流水线，如修改位置
2. 重绘：更新元素的绘制属性，浏览器会重绘，直接进入绘制阶段，如js修改颜色
3. 合成：更改一个既不要布局也不要绘制的属性，浏览器只执行后续的合成操作，如动画


### 1.6. 浏览器加载过程梳理
- 参考：https://github.com/alex/what-happens-when
- 浏览器加载过程
> 1. 用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL
> 2. 用户输入完内容，按下回车键，浏览器导航栏显示loading状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得
> 3. 浏览器进程浏览器构建请求行信息，会通过进程间通信（IPC）将URL请求发送给网络进程
> GET /index.html HTTP1.1
> 4. 网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回；否则，进入网络请求过程
> 5. 网络进程请求DNS返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的IP和端口号，如果没有端口号，http默认80，https默认443。如果是https请求，还需要建立TLS连接。
> 6. Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立TCP连接。
> 7. TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输
> 8. 网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层
> 9. 底层通过物理网络传输给目的服务器主机
> 10. 目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层
> 11. 目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层
> 12. 应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态code301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据code和Location进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段：
> Cache-Control:Max-age=2000
> 响应数据又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到网络进程
> 13. 数据传输完成，TCP四次挥手断开连接。如果，浏览器或者服务器在HTTP头部加上如下信息，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提示资源加载速度
> Connection:Keep-Alive 
> 14. 网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是text/html类型，就通知浏览器进程获取到文档准备渲染
> 15. 浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程
> 16. 浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程
> 17. 浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页
> 18. 渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来

## 2. JavaScript执行机制
### 2.1. 变量提升
- 变量提升：在JavaScript代码执行过程中，JavaScript引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”，变量被提升后，会给变量设置默认值 `undefined` 
- 变量和函数声明在代码里的位置是不变的，而是在编译阶段被JavaScript引擎放入内存中
- 编译代码阶段代码分成执行上下文Excution context（包括变量环境Viriable Environment、词法环境）、可执行代码
- function函数的定义存储到堆（HEAP）中
- 执行阶段：JavaScript引擎按照顺序一行一行的执行“可执行代码”，一段代码如果定义了两个相同名字的函数，那么只有最后一个函数生效

```
graph LR
JavaScript代码-->编译阶段
编译阶段-->执行阶段
```

### 2.2. 调用栈
- 调用栈
	- 用来管理函数调用关系的一种数据结构
	- 是JavaScript引擎追踪函数执行的一个机制，每调用一个函数会为其创建执行上下文，并把该执行上下文压入调用栈，然后JavaScript引擎开始执行函数代码
	- 当一次有多个函数被调用时，通过调用栈就能追踪到哪个函数正在被执行以及各函数之间的调用关系

- 利用浏览器查看调用栈信息：
	1. 通过断点来查看调用栈（Sources中选择js文件添加断点）
	2. 使用 `console.trace()` 函数来输出当前的函数调用关系

- 栈溢出（Stack Overflow）：入栈的执行上下文超过栈的大小
	- 避免方法1：递归调用改造成其他形式
	- 避免方法2：加入定时器的方法来把当前任务拆分为其他很多小任务

### 2.3. 块级作用域
- 作用域（scope）：变量与函数的可访问范围，控制变量和函数的可见性和生命周期
	- 全局作用域：在代码的任何地方都能访问，生命周期伴随着页面的生命周期
	- 函数作用域：在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问，函数执行结束之后，函数内部定义的变量会被销毁
- ES6之前不支持块级作用域，变量提升带来的问题：
	1. 变量容易在不被察觉的情况下被覆盖掉，如在函数内部重新定义全局变量
	2. 本应销毁的变量没有被销毁
- ES6引入 `let` 和 `const` 关键字，使得JavaScript也拥有块级作用域，作用域块内声明的变量不影响块外面的变量
	- `let` 关键字定义的内容可以修改，
	- `const` 关键字定义的内容不能修改

- 在编译阶段：
	- 函数内部通过 `var` 声明的变量，都被放到变量环境中
	- 通过 `let` 声明的变量都被放到 **词法环境（Lexical Environment）**中
	- 函数的作用域内部，通过 `let` 声明的变量并没有被存放到词法环境中

### 2.4. 作用域链
#### 2.4.1.作用域链
- 查找外部变量的链条
- 每个执行上下文的变量环境中，都包含一个外部引用 `outer` ，用来指向外部的执行上下文
- 函数的 `outer` 都指向全局上下文的，在函数中使用了外部变量则JavaScript引擎会去全局上下文中查找

#### 2.4.2. 词法作用域
- 词法作用域：指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符
- 词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系

#### 2.4.3. 闭包
- 在JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数中的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束，但是内部函数引用外部函数的变量依然保存在内存中，这些变量的集合就称为**闭包**
- 如下函数中，在函数foo中的变量myName和test1即使在函数结束后依然存在于内存中，可以供bar通过setName和getName来调用，当执行到 bar.setName 方法时，JavaScript引擎会沿着“当前执行上下文（Local）-->foo函数闭包（Closure）-->全局执行上下文（Global）”的顺序查找myName变量

```javascript
function foo() {
    var myName = " 极客时间 "
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName(" 极客邦 ")
bar.getName()
console.log(bar.getName())
```

- 闭包的回收
	- 如果引用闭包的函数是一个全局变量，那么闭包会一直存在到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄露；
	- 如果引用闭包的函数是一个局部变量，等函数销毁后，在下次JavaScript引擎执行垃圾回收时，判断闭包这块内容如果已经不再使用则垃圾回收器会回收这块内存。
- 闭包的使用原则：如果闭包一直使用，那么可以作为全局变量而存在；如果使用频率不高，而且占用内存又比较大，就尽量让它成为一个局部变量

### 2.5 this
- 执行上下文中包含：变量环境、词法环境、外部环境（outer）、this

- 全局执行上下文中的this对象指向window对象
- 函数执行上下文中的this对象默认也指向window对象

- 设置函数执行上下文中的this值
	1. 通过函数call/bind/apply方法设置 `function.call(bar)`
	2. 使用对象来调用其内部的一个方法，该方法的this指向对象本身；而在全局环境中调用一个函数，函数内部的this指向全局变量window
	3. 通过构造函数设置 `new CreateObj()`

- this没有作用域的限制，所以嵌套函数不会从调用它的函数中继承this，解决办法：
	1. 把this保存为一个self变量，再利用变量的作用域机制传递给嵌套函数
	2. 把嵌套函数改为箭头函数，箭头函数没有自己的执行上下文，所以箭头函数的this就是它外层函数的this

- 如果要让函数执行上下文中的this指向某个对象，最好的方式是通过call方法来显示调用，也可以通过设置JavaScript的“严格模式”来解决，在严格模式下，函数被正常调用时this值为undefined

## 3. V8工作原理
### 3.1. 栈空间和堆空间
#### 3.1.1. 语言分类定义
- 静态语言：使用之前就需要确认其变量数据类型的语言，如C语言
- 动态语言：运行过程中需要检查数据类型的语言，如JavaScript
- 隐式类型转换：赋值过程中对变量类型进行转换
- 弱类型语言：支持隐式类型转换的语言，如C、JavaScript
- 强类型语言：不支持隐式类型转换，如C#、Java

#### 3.1.2. JavaScript对内存使用
- JavaScript在执行过程中，主要有三种类型内存空间：代码空间、栈空间、堆空间
- 栈空间（stack）：即调用栈（call stack），用来存储执行上下文，原始类型的数据值都是直接保存在栈中，空间设置一般都不会太大
- 堆空间（heap）：引用类型的值存放在堆中，对象类型存放在堆空间，在栈空间中只是保留了对象的引用地址，一般空间很大，能存放很多大的数据，但是分配和回收都会占用一定的时间
- 原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址
- JavaScript的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据
- 闭包：在堆空间创建一个“closure”的对象（这是一个内部对象，JavaScript是无法访问的），用来保存myName变量。
	1. 第一步是需要预扫描内部函数；
	2. 第二步是把内部函数引用的外部变量保存到堆中。

### 3.2. 垃圾回收
- 垃圾回收器：释放产生的垃圾数据，如JavaScript、Java、Python等语言
- Chrome开发者工具中的Performance可以观察到内存泄漏

#### 3.2.1. 调用栈中的数据回收
- ESP：记录当前执行状态的指针，指向调用栈中函数的执行上线文，表示当前正在执行函数
- 当前函数执行完成后，JavaScript会将ESP下移到上一层函数的执行上下文，从而销毁当前函数的执行上下文

### 3.2.2. 堆中的数据回收
#### 3.2.2.1. 代际假说（The Generational Hypothesis）
1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
2. 不死的对象，会活得更久

#### 3.2.2.2. V8的垃圾分代收集
-  垃圾回收器的工作流程
	1. 标记空间中活动对象和非活动对象
	2. 回收非活动对象所占据的内存
	3. 内存整理，整理内存碎片（不连续空间）

- 分代：V8会把堆分为新生代和老生代两个区域

- 副垃圾回收器
	- 新生代中存放的是生存时间短的对象，通常只支持`1~8M`的容量，由**副垃圾回收器**回收
	- 使用 `Scavenge` 算法来处理，该算法把空间对半划分为对象区域、空闲区域
	- 对象晋升策略：因为新生区空间不大很容易被存活的对象占满，经过两次垃圾回收依然还存活的对象会被移动到老生区

- 主垃圾回收器
	- 老生代中存放的是生存时间久的对象，容量大很多，由**主垃圾回收器**回收
	- 除了新生区晋升的对象，一些大的对象会直接被分配到老生区
	- 使用 `标记-清除（Mark-Sweep）`算法清理垃圾数据，递归遍历标记活动对象和垃圾数据
	- 使用 `标记-整理（Mark-Compact）`算法整理内存，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

- 全停顿（Stop-The-World）：垃圾回收时运行在JavaScript主线程上的，一旦执行垃圾回收算法，需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行

- 增量标记（Incremental Marking）算法：为了降低老生代的垃圾回收而造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记完成

### 3.3. 编译器和解释器
#### 3.3.1. 编译型语言
- 在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译，如C/C++、GO等都是编译型语言
- 编译过程：源代码-->词法分析、语法分析-->抽象语法树（AST）-->优化代码-->机器码-->生成一个可执行文件

#### 3.3.2. 解释型语言
- 在每次运行时都需要经过解释器对程序进行动态解释和执行，如Python、JavaScript等都属于解释型语言
- 编译过程：源代码-->词法分析、语法分析-->抽象语法树（AST）-->生成字节码-->执行程序、输出结果

#### 3.3.3. V8执行JavaScript代码
#### 3.3.1. 源代码生成抽象语法树（AST）和执行上下文
- JavaScript AST可视化：http://resources.jointjs.com/demos/javascript-ast

- AST的应用：
    - Babel：一个被广泛使用的代码转换器，可以将ES6代码转为ES5代码（ES6-->AST--AST(ES5)）
    - ESLint：检查JavaScript规范的插件

- AST的生成过程：
	1. 分词（tokenize），又称词法分析，作用是将一行行源码拆解成一个个token，token指语法上不能再分的、最小的单个字符或字符串
	2. 解析（parse），又称语法分析，作用是token数据根据语法规则转为AST

#### 3.3.2. 生成字节码
- 解释器Ignition：根据AST生成字节码，并解释执行字节码，同时收集代码信息
- 字节码：介于AST和机器码之间的一种代码，与特定类型的机器码无关，字节码需要听过解释器将其转换为机器码之后才能执行

#### 3.3.3. 执行代码
- 热点代码（HotSpot）：重复执行多次的代码
- 编译器TurboFan：会把热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率
- 即时编译（JIT）：字节码配合解释器和编译器，如Java和Python的虚拟机
- 字节码+JIT技术的使用：JavaScript、苹果的SquirrelFish Extreme和Mozilla的SpiderMonkey

- **优化JavaScript执行效率**
	1. 提升单次脚本的执行速度，避免JavaScript的长任务霸占主线程，这样可以使得页面快速响应交互；
	2. 避免大的内联脚本，因为在解析HTML的过程中，解析和编译也会占用主线程；
	3. 减少JavaScript文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。

## 4. 浏览器中的页面循环系统
### 4.1. 消息队列和事件循环
- 渲染进程专门有一个IO线程用来接收其他进程传进来的消息，接收消息之后会将这些消息组装成任务发给渲染主线程
- Chromium官方源码：https://cs.chromium.org/chromium/src/third_party/blink/public/platform/task_type.h
- 

### 4.2. WebAPI
### 4.3. 宏任务和微任务
### 4.4. Promise
### 4.5. async/await

## 5. 浏览器中的页面
### 5.1. Chrome开发者工具
### 5.2. DOM树
### 5.3. 渲染流水线
### 5.4. 分层和合成机制
### 5.5. 页面性能
### 5.6. 虚拟DOM
### 5.7. 渐进式网页应用（PWA）
### 5.8. WebComponent

## 6. 浏览器中的网络（HTTP）
### 6.1. HTTP/1
### 6.2. HTTP/2
### 6.3. HTTP/3

## 7. 浏览器安全
### 7.1. 同源策略
### 7.2. 跨站脚本攻击（XSS）